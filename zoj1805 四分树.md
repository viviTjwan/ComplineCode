```cpp
//存储结构
class quadtree{
public:
  char value[3];//"00","01","1";00表示全0,01表示全1,1表示mixed
  quadtree *child[4];
  quadtree();//初始化
  //判断两个孩子结点是一样的算法
    bool operator ==(const quadtree& p)const{
    if(strcmp(value,"1")==0||strcmp(value.p.value)!=0)
        return 0;
    else
        return 1;
    }

}


//四分树的建立算法
quadtree *DFS(int r,int c,int len){
    int i;
    bool flag=1;//标识四个孩子是否一样
    quadtree *temp=new quadtree;
    if(len==1){
        temp->value[0]='0';
        temp->value[1]='0'+MAP[r][c];
        temp->value[2]='0';
        return temp;
    }
    len/=2;
    temp->child[0]=DFS(r,c,len);
    temp->child[1]=DFS(r,c+len,len);
    temp->child[2]=DFS(r+len,c,len);
    temp->child[3]=DFS(r+len,c+len,len);
    //检查是都需要合并(即吧四个孩子删除，剪枝工作)
    for(i=1;i<4;i++){
        if(!(*temp->child[0]==*temp->child[i])){
            flag=0;break;//不用合并
        }
        if(flag){
            strcpy(temp->child[0]==temp->child[0]->value);//合并到双亲，并删除四个子树
            for (i=0;i<4;i++){
                delete temp->child[i];
                temp->child[i]=0;
            }
        }
        else{
            strcpy(temp->value,"1");
            //不用合并则更改为混合型
        }
    }
}
```
